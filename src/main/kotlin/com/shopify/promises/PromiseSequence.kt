/*
 *   The MIT License (MIT)
 *
 *   Copyright (c) 2017 Shopify Inc.
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */
@file:JvmName("PromiseSequence")

package com.shopify.promises

import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicReference

/**
 * Constructs the [Promise] that is resolved with [Sequence] of promises generated by the provided function [next]
 *
 * @param seed [Promise] to start the sequence with
 * @param next function to be used for sequence generator that takes previously success resolved value of [Promise] execution and returns
 * the next one until it returns `null` that signals the end of the sequence or until first [Promise] execution failure
 * @return [Promise]`<Sequence<Promise<T, E>, E>`
 */
inline fun <T, E> generatePromiseSequence(seed: Promise<T, E>, crossinline next: (T) -> Promise<T, E>?): Promise<Sequence<Promise<T, E>>, E> {
  val lastValue = AtomicReference<T>()
  val canceled = AtomicBoolean()
  return Promise {
    resolve(generateSequence(seed) { if (canceled.get()) null else next(lastValue.get()) }
      .map { it.onReject { canceled.set(true) } }
      .map { it.onResolve { lastValue.set(it) } }
    )
  }
}

/**
 * Constructs the [Promise] that is resolved with [Sequence] of promises generated by the provided function [next]
 *
 * @param seed [Promise.Result] to start the sequence with
 * @param next function to be used for sequence generator that takes previously [Promise.Result] of [Promise] execution and returns
 * the next one until it returns `null` that signals the end of the sequence
 *
 * @return [Promise]`<Sequence<Promise<T, E>>, Nothing>`
 */
inline fun <T, E> generatePromiseSequence(seed: Promise.Result<T, E>, crossinline next: (Promise.Result<T, E>) -> Promise<T, E>?) = Promise<Sequence<Promise<T, E>>, Nothing> {
  val lastValue = AtomicReference(seed)
  resolve(generateSequence(
    Promise<T, E> {
      when (seed) {
        is Promise.Result.Success -> resolve(seed.value)
        is Promise.Result.Error -> reject(seed.error)
      }
    }
  ) { next(lastValue.get()) }
    .map { it.onResolve { lastValue.set(Promise.Result.Success(it)) } }
    .map { it.onReject { lastValue.set(Promise.Result.Error(it)) } }
  )
}

/**
 * Constructs the [Promise] that is resolved with [Sequence] of promises generated by the provided function [next]
 *
 * @param next function to be used for sequence generator that returns the next [Promise] until `null` that signals the end of the sequence
 *
 * @return [Promise]`<Sequence<Promise<T, E>>, Nothing>`
 */
inline fun <T, E> generatePromiseSequence(crossinline next: () -> Promise<T, E>?) = Promise<Sequence<Promise<T, E>>, Nothing> {
  val canceled = AtomicBoolean()
  onCancel { canceled.set(true) }
  resolve(generateSequence { if (canceled.get()) null else next() })
}

/**
 * Accumulates success resolved [Promise] execution generated by sequence starting with the first element and applying [accumulator] from
 * left to right to current accumulator value and each element.
 *
 * @param initial accumulator value
 * @param accumulator function to accumulate success resolved [Promise] execution values
 * @return [Promise]`<A, E>` that is resolved with accumulated success execution results or rejected with the first [Promise] failure from
 * the sequence
 */
fun <T, E, A> Sequence<Promise<T, E>>.reduceAsync(initial: A, accumulator: (acc: A, value: T) -> A): Promise<A, E> {
  fun Iterator<Promise<T, E>>.reduceAsync(accumulated: A, delegateResult: (Promise.Result<A, E>) -> Unit) {
    val nextPromise = if (hasNext()) next() else null
    nextPromise?.whenComplete(
      onResolve = { reduceAsync(accumulator(accumulated, it), delegateResult) },
      onReject = { delegateResult(Promise.Result.Error(it)) }
    ) ?: delegateResult(Promise.Result.Success(accumulated))
  }
  return Promise<A, E> {
    val delegateCancel = AtomicReference({})
    onCancel {
      delegateCancel.get().invoke()
    }
    onEach { delegateCancel.set(it::cancel) }
      .iterator()
      .reduceAsync(initial) { dispatch(it) }
  }
}

/**
 * Accumulates success resolved [Promise] execution generated by sequence.
 *
 * @return [Promise]`<List<T>, E>` that is resolved with accumulated success execution results or rejected with the first [Promise] failure from
 * the sequence
 */
fun <T, E> Sequence<Promise<T, E>>.reduceAsync(): Promise<List<T>, E> {
  return reduceAsync(emptyList()) { acc, value -> acc + value }
}

/**
 * Create [Promise]`Array<T>, E` that will wait until all provided promises are successfully resolved or one of them fails
 *
 * If one of provided promises failed remaining promises will be terminated and this [Promise] will fail too with the same error.
 * Execution results are kept in order.
 *
 * @return [Promise]`<List<T>, E>`
 */
fun <T, E> Sequence<Promise<T, E>>.resolveAll(): Promise<List<T>, E> {
  return Promise {
    val subscriber = this
    val promises = toList()
    if (promises.isEmpty()) {
      resolve(emptyList())
    } else {
      val remainingCount = AtomicInteger(promises.size)
      val canceled = AtomicBoolean()
      val cancel = {
        canceled.set(true)
        promises.forEach { it.cancel() }
      }
      onCancel(cancel)

      val result = Array<Any?>(promises.size) { Unit }
      promises.forEachIndexed { index, promise ->
        if (canceled.get()) return@forEachIndexed

        promise.whenComplete(
          onResolve = {
            result[index] = it as Any?
            if (remainingCount.decrementAndGet() == 0 && !canceled.get()) {
              subscriber.resolve(result.map { it as T })
            }
          },
          onReject = {
            cancel().apply { subscriber.reject(it) }
          }
        )
      }
    }
  }
}